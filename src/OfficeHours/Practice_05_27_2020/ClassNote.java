package OfficeHours.Practice_05_27_2020;

public class ClassNote {

    /*
    05/27/2020
Practice Topics: Method overloading & Overriding
			     OOP Summary (Encapsulation & Inheritance)

office hour: 2pm ~ 4pm

Package Name: Practice_05_27_2020

overloading: same method name, different parameter (MUST)
             return type does't matter
             access modifier does not matter
             any method can be overloaded


overriding: same name & same parameter
		    access modifiers need to be same or more visible
		    return-type MUST be same
		    ONLy the instance method (visible) can be overriden

	pre-conditioon: MUST take place in subclass (child)

	@Override: checks if method is being overriden


why we need overriding:
	to implement different function/implemntation to the method

visibility:
	public > protected > default > private


example1:
		car:
			start(): push button


		BMW:
			start(): push the start button

		Toyota:
			start(): Insert key

Ex2:
		shape:
			Area():


		Circle:
			Area(): PI * R


		Triangle:
			Area(): Base * Height * 1/2

		same method name & same paremeter, but different implementation





Encapsulation: hiding the data by giving private access modifier

				other sources can only access to it through public getter/setter

				getter (READ ONLY): returns the private data
				setter(Write ONLY): assigning the argument to the private data


Inheritance: building relationships between class
		     super & sub relation

		     super class: cannot inherit anything from sub class

		     sub class: inherts the methods and variables (Visible) from super class

		     advantages:
		     	resuable
		     	readble
		     	orginzed
		     	easy to memorize
		     	easy to main tain


			TestBase:
				setUp(): login ...

			Test1:

			Test2:
			....


tomorrow's topic: Exceptions

				  Abstraction
				  Ploymorphisim
				  Collection
				  Maps






     */


}
